--[[
ğŸ’€ è´´å§ç‹‚æš´ä¸“ç”¨æ£€æµ‹å¼•æ“ v5.0
- ä¸“é—¨é€‚é…èŠå¤©è®°å½•å™¨ï¼šscan() è¾“å‡º hit/score/hits/categories
- ä¸­è‹±åŒé€šé“ï¼šFULL(ä¿ç•™ä¸­æ–‡) + ALNUM(è‹±æ•°å‹ç¼©)
- å…¼å®¹èŠ±å¼å†™æ³•ï¼šå…¨è§’ã€leetã€å¤§å°å†™ã€ç©ºæ ¼/ç¬¦å·æ‹†åˆ†
- ä½è¯¯ä¼¤ï¼šçŸ­è‹±æ–‡è¯è¾¹ç•Œåˆ¤å®š + å¸¸è§ç™½åå•
- æ—  goto / labelï¼Œè§„é¿éƒ¨åˆ†æ‰§è¡Œå™¨è¯­æ³•å…¼å®¹é—®é¢˜
]]

local Detector = {}
Detector.__index = Detector

-- ============ helpers ============
local function clamp(n,a,b)
	if n<a then return a elseif n>b then return b else return n end
end

local function shallowCopy(arr)
	local out = {}
	for i=1,#arr do out[i]=arr[i] end
	return out
end

local function categoryWeight(cat)
	cat = string.lower(tostring(cat or ""))
	if cat:find("advanced") or cat:find("dialect") then return 5 end
	if cat:find("basic") then return 4 end
	if cat:find("leet") or cat:find("pinyin") or cat:find("abbrev") or cat:find("initial") then return 4 end
	if cat:find("english") then return 4 end
	if cat:find("euphem") then return 3 end
	if cat:find("rage") then return 2 end
	if cat:find("memes") then return 1 end
	return 2
end

local function isAsciiAlphaNumByte(b)
	return (b>=48 and b<=57) or (b>=97 and b<=122) or (b>=65 and b<=90)
end

local function toLowerASCII(s)
	return (s:gsub("%u", function(c)
		return string.char(c:byte()+32)
	end))
end

local FULLWIDTH_MAP = {
	["ï¼"]="!",["ï¼‚"]='"',["ï¼ƒ"]="#",["ï¼„"]="$",["ï¼…"]="%",["ï¼†"]="&",["ï¼‡"]="'",
	["ï¼ˆ"]="(",["ï¼‰"]=")",["ï¼Š"]="*",["ï¼‹"]="+",["ï¼Œ"]=",",["ï¼"]="-",["ï¼"]=".",
	["ï¼"]="/",["ï¼š"]=":",["ï¼›"]=";",["ï¼œ"]="<",["ï¼"]="=",["ï¼"]=">",["ï¼Ÿ"]="?",
	["ï¼ "]="@",["ï¼»"]="[",["ï¼¼"]="\\",["ï¼½"]="]",["ï¼¾"]="^",["ï¼¿"]="_",["ï½€"]="`",
	["ï½›"]="{",["ï½œ"]="|",["ï½"]="}",["ï½"]="~",["ã€€"]=" "
}

local LEET_MAP = {
	["@"]= "a", ["$"]= "s", ["!"]= "i", ["|"]= "i",
	["0"]= "o", ["1"]= "i", ["3"]= "e", ["4"]= "a", ["5"]= "s", ["7"]= "t", ["8"]= "b", ["9"]= "g",
}

local function safeUtf8(s)
	if type(s)~="string" then return "" end
	if s=="" then return "" end
	local ok, len = pcall(function() return utf8.len(s) end)
	if ok and len ~= nil then return s end
	-- éæ³•UTF8å…œåº•ï¼šå»é™¤é«˜ä½å­—èŠ‚ï¼Œè‡³å°‘ä¿è¯ä¸å´©
	return (s:gsub("[\128-\255]", ""))
end

local function normalizeDual(s)
	s = safeUtf8(s)
	s = s:gsub("[%z\1-\31\127-\159\u{200B}-\u{200F}\u{2060}\u{FEFF}]", "")
	s = s:gsub("[\u{0300}-\u{036F}\u{1AB0}-\u{1AFF}\u{1DC0}-\u{1DFF}\u{20D0}-\u{20FF}\u{FE20}-\u{FE2F}]", "")
	s = toLowerASCII(s)

	-- å…¨è§’ç¬¦å·æ˜ å°„
	s = s:gsub("[%z\1-\127\u{3000}-\u{FFEF}]", function(ch)
		return FULLWIDTH_MAP[ch] or ch
	end)

	-- leetæ˜ å°„
	s = s:gsub(".", function(ch)
		return LEET_MAP[ch] or ch
	end)

	local fullBuf, alnumBuf = {}, {}
	local i = 1
	while i <= #s do
		local b = s:byte(i)
		if b and b < 128 then
			local ch = s:sub(i,i)
			if isAsciiAlphaNumByte(b) then
				fullBuf[#fullBuf+1] = ch
				alnumBuf[#alnumBuf+1] = ch
			else
				-- FULL ä¸ä¿ç•™çº¯ç¬¦å·ï¼Œå‡å°‘å™ªéŸ³
			end
			i += 1
		else
			-- UTF8å­—ç¬¦ï¼ˆä¸­æ–‡ç­‰ï¼‰ä¿ç•™åˆ° FULL
			local ok, cp = pcall(function() return utf8.codepoint(s, i) end)
			if ok and cp then
				local ch = utf8.char(cp)
				fullBuf[#fullBuf+1] = ch
				i += #ch
			else
				i += 1
			end
		end
	end

	local full = table.concat(fullBuf)
	local alnum = table.concat(alnumBuf)

	-- è‹±æ–‡æ‹‰é•¿å‹ç¼©ï¼šfuuuuuck -> fuuck
	full = full:gsub("(%a)%1%1+", "%1%1")
	alnum = alnum:gsub("(%a)%1%1+", "%1%1")

	return full, alnum
end

-- ============ AC automaton ============
local function newNode()
	return {next={}, fail=1, out=nil}
end

local function pushOut(node, p)
	if not node.out then node.out = {p} else node.out[#node.out+1] = p end
end

local function buildAC(payloads)
	local nodes = {newNode()} -- root=1

	for _,p in ipairs(payloads) do
		local cur = 1
		local w = p.norm
		for i=1,#w do
			local c = w:byte(i)
			local nxt = nodes[cur].next[c]
			if not nxt then
				nodes[#nodes+1] = newNode()
				nxt = #nodes
				nodes[cur].next[c] = nxt
			end
			cur = nxt
		end
		pushOut(nodes[cur], p)
	end

	local q, head = {}, 1
	for _,nxt in pairs(nodes[1].next) do
		nodes[nxt].fail = 1
		q[#q+1] = nxt
	end

	while head <= #q do
		local v = q[head]; head += 1
		for ch, u in pairs(nodes[v].next) do
			local f = nodes[v].fail
			while f ~= 1 and not nodes[f].next[ch] do
				f = nodes[f].fail
			end
			local link = nodes[f].next[ch] or 1
			nodes[u].fail = link
			if nodes[link].out then
				if nodes[u].out then
					for i=1,#nodes[link].out do nodes[u].out[#nodes[u].out+1] = nodes[link].out[i] end
				else
					nodes[u].out = shallowCopy(nodes[link].out)
				end
			end
			q[#q+1] = u
		end
	end

	return nodes
end

local function boundaryOK(s, st, ed)
	local lb = (st>1) and s:byte(st-1) or nil
	local rb = (ed<#s) and s:byte(ed+1) or nil
	local leftOK = (not lb) or (not isAsciiAlphaNumByte(lb))
	local rightOK = (not rb) or (not isAsciiAlphaNumByte(rb))
	return leftOK and rightOK
end

local function acScan(nodes, s, onHit)
	local st = 1
	for i=1,#s do
		local c = s:byte(i)
		while st ~= 1 and not nodes[st].next[c] do st = nodes[st].fail end
		st = nodes[st].next[c] or 1
		local out = nodes[st].out
		if out then
			for k=1,#out do
				onHit(out[k], i)
			end
		end
	end
end

-- å¸¸è§çŸ­è¯è¯¯åˆ¤é˜²æŠ¤ï¼ˆALNUMé€šé“ï¼‰
local SHORT_EN_STRICT = {
	ass=true, damn=true, crap=true
}

-- ============ API ============
function Detector.new(wordsTable, opts)
	wordsTable = wordsTable or {}
	opts = opts or {}

	local payloadFull, payloadAlnum = {}, {}
	local uniqFull, uniqAlnum = {}, {}

	for cat, list in pairs(wordsTable) do
		if type(list)=="table" then
			for i=1,#list do
				local raw = tostring(list[i] or "")
				if raw ~= "" then
					local full, alnum = normalizeDual(raw)
					local w = categoryWeight(cat)

					if #full >= 2 and not uniqFull[full] then
						uniqFull[full] = true
						payloadFull[#payloadFull+1] = {norm=full, raw=raw, cat=cat, weight=w, channel="full"}
					end

					if #alnum >= 2 and not uniqAlnum[alnum] then
						uniqAlnum[alnum] = true
						payloadAlnum[#payloadAlnum+1] = {norm=alnum, raw=raw, cat=cat, weight=w, channel="alnum"}
					end
				end
			end
		end
	end

	local self = setmetatable({}, Detector)
	self.acFull = buildAC(payloadFull)
	self.acAlnum = buildAC(payloadAlnum)
	self.opts = {
		maxHits = tonumber(opts.maxHits) or 24,
		scoreCap = tonumber(opts.scoreCap) or 100,
	}
	return self
end

function Detector:scan(text)
	local full, alnum = normalizeDual(tostring(text or ""))
	local hitMap = {}
	local hits = {}
	local categories = {}
	local score = 0

	local function consume(payload, ed, channelText)
		local st = ed - #payload.norm + 1
		if st < 1 then return end

		if payload.channel == "alnum" then
			if SHORT_EN_STRICT[payload.norm] and not boundaryOK(channelText, st, ed) then
				return
			end
		end

		local key = payload.channel.."|"..payload.norm.."|"..st
		if hitMap[key] then return end
		hitMap[key] = true

		hits[#hits+1] = {
			word = payload.raw,
			norm = payload.norm,
			cat = payload.cat,
			channel = payload.channel,
			startPos = st,
			endPos = ed,
		}
		categories[payload.cat] = true
		score += payload.weight
	end

	acScan(self.acFull, full, function(p, ed)
		consume(p, ed, full)
	end)

	acScan(self.acAlnum, alnum, function(p, ed)
		consume(p, ed, alnum)
	end)

	if #hits > self.opts.maxHits then
		while #hits > self.opts.maxHits do table.remove(hits) end
	end

	score = clamp(score, 0, self.opts.scoreCap)

	return {
		hit = #hits > 0,
		score = score,
		hits = hits,
		categories = categories,
		norm = {full=full, alnum=alnum},
	}
end

return Detector
