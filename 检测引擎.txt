--[[
ğŸ’€ ç»ˆææ•æ„Ÿè¯/è„è¯æ£€æµ‹å¼•æ“ v4.1ï¼ˆä¿®å¤ï¼šinvalid UTF-8 code ä¸å†å´©æºƒï¼‰
- ä¿®å¤ï¼šå­—åº“/è¾“å…¥å«éæ³•UTF-8å­—èŠ‚æ—¶ utf8.codes / utf8.codepoint æŠ¥é”™
- ä¿®å¤ï¼šcache æ¸…ç† table.getn å¯¹ map æ— æ•ˆ
- ä¿æŒï¼šåŒé€šé“ normalize + Ahoâ€“Corasick + fuzzy short
]]

local Detector = {}
Detector.__index = Detector

-- ========= åˆ†ç±»æƒé‡ =========
local function categoryWeight(cat)
	cat = (cat or ""):lower()
	if cat:find("advanced") or cat:find("dialect") then return 4 end
	if cat:find("basic") then return 3 end
	if cat:find("leet") or cat:find("pinyin") or cat:find("abbrev") or cat:find("initial") then return 4 end
	if cat:find("euphem") then return 2 end
	if cat:find("memes") or cat:find("sarcasm") or cat:find("rage") then return 1 end
	return 2
end

-- ========= UTF-8 å®‰å…¨å¤„ç†ï¼ˆæ ¸å¿ƒä¿®å¤ï¼‰ =========
local function isValidUtf8(s)
	-- Luau: utf8.len è¿”å› nil è¡¨ç¤ºéæ³•ï¼Œå¹¶ç»™å‡ºé”™è¯¯ä½ç½®
	local ok, len = pcall(function() return utf8.len(s) end)
	return ok and len ~= nil
end

local function forceValidUtf8(s)
	-- å¦‚æœéæ³•ï¼šç²—æš´å‰”æ‰æ‰€æœ‰ 0x80-0xFF å­—èŠ‚ï¼Œä¿è¯ä¸å´©ï¼ˆä»£ä»·ï¼šä¸¢å¤±éƒ¨åˆ†éASCIIå­—ç¬¦ï¼‰
	-- ç›®çš„ï¼šå­—åº“æ„å»ºå¿…é¡»ç¨³å®š
	if not isValidUtf8(s) then
		s = s:gsub("[\128-\255]", "")
	end
	return s
end

local function safeUtf8Codes(s)
	-- è¿”å›ä¸€ä¸ªâ€œå®‰å…¨è¿­ä»£å™¨â€ï¼šé‡åˆ°éæ³•UTF8å°±é™çº§æˆ byte éå†ï¼ˆåªä¿è¯ä¸å´©ï¼‰
	s = forceValidUtf8(s)
	local ok = pcall(function()
		for _ in utf8.codes(s) do end
	end)
	if ok then
		return utf8.codes(s), true
	end

	-- byte fallback
	local i = 0
	return function()
		i += 1
		if i > #s then return nil end
		return i, s:byte(i)
	end, false
end

local function safeCodepoint(s, i)
	-- å®‰å…¨ç‰ˆ utf8.codepointï¼šå¤±è´¥å°±è¿”å› nil å¹¶å‰è¿›1å­—èŠ‚
	local ok, cp = pcall(function() return utf8.codepoint(s, i) end)
	if ok then return cp, nil end
	return nil, "bad utf8"
end

-- ========= Unicode/é›¶å®½/ç»„åˆç¬¦/å…¨è§’æ¸…æ´— =========
local function removeInvisibleAndControls(s)
	-- æ§åˆ¶å­—ç¬¦ + å¸¸è§é›¶å®½ + BOM
	-- å…ˆ forceValidUtf8 é¿å… gsub/utf8 åœ¨å¥‡æ€ªå­—èŠ‚ä¸Šè¿é”æŠ¥é”™
	s = forceValidUtf8(s)
	return s:gsub("[%z\1-\31\127-\159\u{200B}-\u{200F}\u{2060}\u{FEFF}]", "")
end

local FULLWIDTH_MAP = {
	["ï¼"]="!",["ï¼‚"]='"',["ï¼ƒ"]="#",["ï¼„"]="$",["ï¼…"]="%",["ï¼†"]="&",["ï¼‡"]="'",
	["ï¼ˆ"]="(",["ï¼‰"]=")",["ï¼Š"]="*",["ï¼‹"]="+",["ï¼Œ"]=",",["ï¼"]="-",["ï¼"]=".",
	["ï¼"]="/",["ï¼š"]=":",["ï¼›"]=";",["ï¼œ"]="<",["ï¼"]="=",["ï¼"]=">",["ï¼Ÿ"]="?",
	["ï¼ "]="@",["ï¼»"]="[",["ï¼¼"]="\\",["ï¼½"]="]",["ï¼¾"]="^",["ï¼¿"]="_",["ï½€"]="`",
	["ï½›"]="{",["ï½œ"]="|",["ï½"]="}",["ï½"]="~",
	["ã€€"]=" ",
}

local CHAR_MAP = {
	["@"]="a", ["$"]="s", ["!"]="i", ["|"]="i",
	["0"]="o", ["1"]="i", ["3"]="e", ["4"]="a", ["5"]="s", ["7"]="t",
	["8"]="b", ["9"]="g",
}

local function toLowerASCII(s)
	return (s:gsub("%u", function(c) return string.char(c:byte()+32) end))
end

local function stripCombiningMarks(s)
	s = forceValidUtf8(s)
	return s:gsub("[\u{0300}-\u{036F}\u{1AB0}-\u{1AFF}\u{1DC0}-\u{1DFF}\u{20D0}-\u{20FF}\u{FE20}-\u{FE2F}]", "")
end

local function mapFullwidthAndLeet(s)
	s = forceValidUtf8(s)

	-- å…¨è§’ -> åŠè§’ï¼ˆæ˜ å°„å¸¸è§ç¬¦å·/ç©ºæ ¼ï¼‰
	s = s:gsub("[%z\1-\127\u{3000}-\u{FFEF}]", function(ch)
		return FULLWIDTH_MAP[ch] or ch
	end)

	-- leet å•å­—ç¬¦æ˜ å°„ï¼ˆåªå¯¹ ASCII å®‰å…¨ï¼ŒéASCIIå­—èŠ‚åŸæ ·è¿”å›ï¼‰
	s = s:gsub(".", function(ch)
		return CHAR_MAP[ch] or ch
	end)

	return s
end

local function collapseRepeatsUtf8(s)
	-- å…ˆä¿è¯ä¸ä¼š invalid utf8
	s = forceValidUtf8(s)

	-- è‹±æ–‡å‹ç¼©æ›´ç‹ 
	s = s:gsub("(%a)%1%1+", "%1%1")

	-- UTF8å®‰å…¨éå†ï¼ˆéæ³•å°±é™çº§ä¸ºbyteï¼‰
	local iter, isUtf = safeUtf8Codes(s)
	if not isUtf then
		-- byte fallbackï¼šæœ€å¤šä¿ç•™2è¿
		local out={}
		local last=nil
		local run=0
		for _,b in iter do
			if b==last then
				run += 1
				if run <= 2 then out[#out+1]=string.char(b) end
			else
				last=b; run=1
				out[#out+1]=string.char(b)
			end
		end
		return table.concat(out)
	end

	-- æ­£å¸¸ UTF8ï¼šæœ€å¤šç•™2è¿
	local out={}
	local last=nil
	local run=0
	for _,cp in iter do
		if cp==last then
			run += 1
			if run <= 2 then out[#out+1]=utf8.char(cp) end
		else
			last=cp; run=1
			out[#out+1]=utf8.char(cp)
		end
	end
	return table.concat(out)
end

-- ========= å½’ä¸€åŒ–ï¼šè¾“å‡º FULL / ALNUM =========
local function normalizeDual(s)
	if not s or s=="" then return "", "" end
	s = forceValidUtf8(s)
	s = removeInvisibleAndControls(s)
	s = stripCombiningMarks(s)
	s = toLowerASCII(s)
	s = mapFullwidthAndLeet(s)

	local fullBuf, alnumBuf = {}, {}
	local i = 1
	while i <= #s do
		local b = s:byte(i)
		if b < 128 then
			local ch = s:sub(i,i)
			local isDigit = (b >= 48 and b <= 57)
			local isAlpha = (b >= 97 and b <= 122) or (b >= 65 and b <= 90)
			if isDigit or isAlpha then
				fullBuf[#fullBuf+1] = ch
				alnumBuf[#alnumBuf+1] = ch
			end
			i += 1
		else
			-- UTF8 å¤šå­—èŠ‚ï¼šå®‰å…¨ codepoint
			local cp, err = safeCodepoint(s, i)
			if cp then
				local ch = utf8.char(cp)
				fullBuf[#fullBuf+1] = ch
				i += #ch
			else
				-- è·³è¿‡åå­—èŠ‚ï¼ˆå…³é”®ï¼šä¸å´©ï¼‰
				i += 1
			end
		end
	end

	local full = collapseRepeatsUtf8(table.concat(fullBuf))
	local alnum = collapseRepeatsUtf8(table.concat(alnumBuf))
	return full, alnum
end

-- ========= Ahoâ€“Corasick =========
local function newNode()
	return {next = {}, fail = 1, out = nil}
end

local function addOut(node, payload)
	if not node.out then node.out = {payload} else node.out[#node.out+1] = payload end
end

local function buildAC(payloads)
	local nodes = { newNode() } -- root=1

	local function insert(word, payload)
		local cur = 1
		for i=1,#word do
			local c = word:byte(i)
			local nxt = nodes[cur].next[c]
			if not nxt then
				nodes[#nodes+1] = newNode()
				nxt = #nodes
				nodes[cur].next[c] = nxt
			end
			cur = nxt
		end
		addOut(nodes[cur], payload)
	end

	for _,p in ipairs(payloads) do
		insert(p.norm, p)
	end

	local q, head = {}, 1
	for _, nxt in pairs(nodes[1].next) do
		nodes[nxt].fail = 1
		q[#q+1] = nxt
	end

	while head <= #q do
		local v = q[head]; head += 1
		for ch, u in pairs(nodes[v].next) do
			local f = nodes[v].fail
			while f ~= 1 and not nodes[f].next[ch] do
				f = nodes[f].fail
			end
			local link = nodes[f].next[ch] or 1
			nodes[u].fail = link
			if nodes[link].out then
				if nodes[u].out then
					for i=1,#nodes[link].out do nodes[u].out[#nodes[u].out+1] = nodes[link].out[i] end
				else
					-- table.clone åœ¨ Luau æœ‰ï¼›æ²¡æœ‰ä¹Ÿä¸è‡´å‘½
					nodes[u].out = table.clone and table.clone(nodes[link].out) or nodes[link].out
				end
			end
			q[#q+1] = u
		end
	end

	return nodes
end

local function acScan(nodes, s, hitMap, outArr)
	local st = 1
	for i=1,#s do
		local c = s:byte(i)
		while st ~= 1 and not nodes[st].next[c] do
			st = nodes[st].fail
		end
		st = nodes[st].next[c] or 1
		local out = nodes[st].out
		if out then
			for k=1,#out do
				local p = out[k]
				local key = p.norm .. "|" .. p.cat
				if not hitMap[key] then
					hitMap[key] = true
					outArr[#outArr+1] = { word = p.raw, category = p.cat, weight = p.weight }
				end
			end
		end
	end
end

-- ========= fuzzy short =========
local function levenshteinLimit(a, b, limit)
	if a == b then return 0 end
	local la, lb = #a, #b
	if math.abs(la - lb) > limit then return limit + 1 end
	local prev = {}
	for j=0,lb do prev[j] = j end
	for i=1,la do
		local cur = {[0]=i}
		local rowMin = cur[0]
		local ai = a:byte(i)
		for j=1,lb do
			local cost = (ai == b:byte(j)) and 0 or 1
			local v = math.min(prev[j] + 1, cur[j-1] + 1, prev[j-1] + cost)
			cur[j] = v
			if v < rowMin then rowMin = v end
		end
		if rowMin > limit then return limit + 1 end
		prev = cur
	end
	return prev[lb]
end

local function fuzzyShortHits(alnum, targets, limit, hitMap, outArr)
	if alnum == "" then return end
	for _,t in ipairs(targets) do
		local lt = #t
		if #alnum >= lt then
			for i=1,(#alnum - lt + 1) do
				local sub = alnum:sub(i, i+lt-1)
				if levenshteinLimit(sub, t, limit) <= limit then
					local key = t .. "|fuzzy"
					if not hitMap[key] then
						hitMap[key] = true
						outArr[#outArr+1] = { word = t, category = "fuzzy_short", weight = 4 }
					end
					break
				end
			end
		end
	end
end

local function countMap(t)
	local c=0
	for _ in pairs(t) do c+=1 end
	return c
end

-- ========= Detector.new / scan =========
function Detector.new(wordsTable)
	-- flatten è¯åº“ï¼ˆå¼ºåˆ¶å°†æ¯ä¸ª raw è¯æ¡å˜æˆåˆæ³•UTF8å†å¤„ç†ï¼‰
	local payloads = {}
	local seen = {}

	for cat, list in pairs(wordsTable) do
		if type(list) == "table" then
			local wgt = categoryWeight(cat)
			for i=1,#list do
				local raw = list[i]
				if type(raw) == "string" and raw ~= "" then
					raw = forceValidUtf8(raw) -- âœ… æ ¸å¿ƒï¼šå…ˆä¿è¯ä¸ç‚¸
					local full, alnum = normalizeDual(raw)

					if full ~= "" then
						local key = "F|"..full.."|"..tostring(cat)
						if not seen[key] then
							seen[key] = true
							payloads[#payloads+1] = { norm = full, raw = raw, cat = tostring(cat), weight = wgt }
						end
					end
					if alnum ~= "" and alnum ~= full then
						local key2 = "A|"..alnum.."|"..tostring(cat)
						if not seen[key2] then
							seen[key2] = true
							payloads[#payloads+1] = { norm = alnum, raw = raw, cat = tostring(cat), weight = wgt }
						end
					end
				end
			end
		end
	end

	local self = setmetatable({
		ac = buildAC(payloads),
		fuzzy = true,
		fuzzyLimit = 1,
		fuzzyTargets = {"sb","cnm","nmsl","tmd","wdnmd","mlgb","wqnmlgb"},
		cache = {},
		cacheMax = 200,
	}, Detector)

	return self
end

function Detector:scan(text)
	if not text or text == "" then
		return {hit=false, level="clean", score=0, matches={}, norm_full="", norm_alnum=""}
	end

	-- å…ˆå¼ºåˆ¶åˆæ³•UTF8ï¼Œé¿å… scan æ—¶å´©
	text = forceValidUtf8(text)

	local cached = self.cache[text]
	if cached then return cached end

	local full, alnum = normalizeDual(text)

	local hitMap = {}
	local matches = {}

	acScan(self.ac, full, hitMap, matches)
	if alnum ~= full then acScan(self.ac, alnum, hitMap, matches) end

	if self.fuzzy and #matches == 0 then
		fuzzyShortHits(alnum, self.fuzzyTargets, self.fuzzyLimit, hitMap, matches)
	end

	local score = 0
	for i=1,#matches do
		score += (matches[i].weight or 1)
	end

	local level = "clean"
	if score >= 10 then level = "critical"
	elseif score >= 6 then level = "high"
	elseif score >= 3 then level = "medium"
	elseif score >= 1 then level = "low"
	end

	local res = {
		hit = (#matches > 0),
		level = level,
		score = score,
		matches = matches,
		norm_full = full,
		norm_alnum = alnum,
	}

	-- âœ… map cache æ­£ç¡®æ¸…ç†
	if self.cacheMax > 0 then
		if countMap(self.cache) > self.cacheMax then
			self.cache = {}
		end
		self.cache[text] = res
	end

	return res
end

return Detector
