--[[
ğŸ’€ ç»ˆææ•æ„Ÿè¯/è„è¯æ£€æµ‹å¼•æ“ v4.0ï¼ˆæ£€æµ‹ç‡â†‘â†‘â†‘ï¼‰
- Unicode/é›¶å®½/å…¨è§’/ç»„åˆç¬¦æ¸…æ´—ï¼ˆæ›´å¼ºï¼‰
- æ–­è¯/æ’ç¬¦å·ç»•è¿‡è¯†åˆ«ï¼ˆæ›´å¼ºï¼‰
- åŒé€šé“æ‰«æï¼š
  A) FULLï¼šä¿ç•™ä¸­æ–‡+å­—æ¯æ•°å­—ï¼ˆå¸¸è§„è„è¯/æ•æ„Ÿè¯ï¼‰
  B) ALNUMï¼šä»…å­—æ¯æ•°å­—ï¼ˆä¸“æŠ“æ‹¼éŸ³/ç¼©å†™/leet/æ•°å­—æ¢—ï¼‰
- Ahoâ€“Corasick è‡ªåŠ¨æœºï¼ˆ5000+è¯åº“ä¹Ÿç¨³ï¼‰
- çŸ­ç¼©å†™æ»‘çª—æ¨¡ç³Šè¡¥åˆ€ï¼ˆé˜²â€œå°‘æ‰“/é”™æ‰“/æ’ä¸€å­—ç¬¦â€ï¼‰
- åˆ†çº§è¯„åˆ†ï¼ˆclean/medium/high/criticalï¼‰

ç”¨æ³•ï¼š
local words = loadstring(game:HttpGet("ä½ çš„rawå­—åº“"))()
local Detector = loadstring(game:HttpGet("ä½ çš„Detectorè„šæœ¬raw"))()
local det = Detector.new(words)

local r = det:scan("n m s l ä½ *å¦ˆ c4o f**k")
print(r.hit, r.level, r.score, r.norm_full, r.norm_alnum)
for _,m in ipairs(r.matches) do
    print(m.word, m.category, m.weight)
end
]]

local Detector = {}
Detector.__index = Detector

-- ========= åŸºç¡€ï¼šå¯è°ƒæƒé‡ï¼ˆæŒ‰åˆ†ç±»åå…³é”®è¯ï¼‰ =========
local function categoryWeight(cat)
    cat = (cat or ""):lower()
    if cat:find("advanced") or cat:find("dialect") then return 4 end
    if cat:find("basic") then return 3 end
    if cat:find("leet") or cat:find("pinyin") or cat:find("abbrev") or cat:find("initial") then return 4 end
    if cat:find("euphem") then return 2 end
    if cat:find("memes") or cat:find("sarcasm") or cat:find("rage") then return 1 end
    return 2
end

-- ========= Unicode/é›¶å®½/ç»„åˆç¬¦/å…¨è§’æ¸…æ´— =========
local function removeInvisibleAndControls(s)
    -- æ§åˆ¶å­—ç¬¦ + å¸¸è§é›¶å®½ + BOM
    return s:gsub("[%z\1-\31\127-\159\u{200B}-\u{200F}\u{2060}\u{FEFF}]", "")
end

local FULLWIDTH_MAP = {
    ["ï¼"]="!",["ï¼‚"]='"',["ï¼ƒ"]="#",["ï¼„"]="$",["ï¼…"]="%",["ï¼†"]="&",["ï¼‡"]="'",
    ["ï¼ˆ"]="(",["ï¼‰"]=")",["ï¼Š"]="*",["ï¼‹"]="+",["ï¼Œ"]=",",["ï¼"]="-",["ï¼"]=".",
    ["ï¼"]="/",["ï¼š"]=":",["ï¼›"]=";",["ï¼œ"]="<",["ï¼"]="=",["ï¼"]=">",["ï¼Ÿ"]="?",
    ["ï¼ "]="@",["ï¼»"]="[",["ï¼¼"]="\\",["ï¼½"]="]",["ï¼¾"]="^",["ï¼¿"]="_",["ï½€"]="`",
    ["ï½›"]="{",["ï½œ"]="|",["ï½"]="}",["ï½"]="~",
    ["ã€€"]=" ", -- å…¨è§’ç©ºæ ¼
}

-- å¸¸è§ leet/è°éŸ³æ˜ å°„ï¼ˆå¯ç»§ç»­åŠ ï¼‰
local CHAR_MAP = {
    ["@"]="a", ["$"]="s", ["!"]="i", ["|"]="i",
    ["0"]="o", ["1"]="i", ["3"]="e", ["4"]="a", ["5"]="s", ["7"]="t",
    ["8"]="b", ["9"]="g",
}

local function toLowerASCII(s)
    return (s:gsub("%u", function(c) return string.char(c:byte()+32) end))
end

local function collapseRepeatsUtf8(s)
    -- è‹±æ–‡å‹ç¼©æ›´ç‹ 
    s = s:gsub("(%a)%1%1+", "%1%1")
    -- ä¸­æ–‡/å…¶å®ƒï¼šæœ€å¤šç•™2è¿
    local out = {}
    local last, run = nil, 0
    for _, cp in utf8.codes(s) do
        if cp == last then
            run += 1
            if run <= 2 then out[#out+1] = utf8.char(cp) end
        else
            last, run = cp, 1
            out[#out+1] = utf8.char(cp)
        end
    end
    return table.concat(out)
end

local function stripCombiningMarks(s)
    -- å»æ‰å¸¸è§ç»„åˆéŸ³æ ‡åŒºé—´ï¼ˆå¯¹â€œfÌ·uÌ·cÌ·kÌ·â€è¿™ç±»æœ‰ç”¨ï¼‰
    -- æ³¨æ„ï¼šLua æ¨¡å¼ä¸ç›´æ¥æ”¯æŒ Unicode åˆ†ç±»ï¼Œæ‰€ä»¥ç”¨èŒƒå›´ç¡¬å‰”ä¸€äº›å¸¸è§æ®µ
    return s:gsub("[\u{0300}-\u{036F}\u{1AB0}-\u{1AFF}\u{1DC0}-\u{1DFF}\u{20D0}-\u{20FF}\u{FE20}-\u{FE2F}]", "")
end

local function mapFullwidthAndLeet(s)
    -- å…¨è§’ -> åŠè§’ï¼ˆåªæ˜ å°„å¸¸è§ç¬¦å·/ç©ºæ ¼ï¼Œå¤Ÿç”¨äº†ï¼‰
    s = s:gsub("[%z\1-\127\u{3000}-\u{FFEF}]", function(ch)
        return FULLWIDTH_MAP[ch] or ch
    end)

    -- leet å•å­—ç¬¦æ˜ å°„ï¼ˆASCIIï¼‰
    s = s:gsub(".", function(ch)
        return CHAR_MAP[ch] or ch
    end)

    return s
end

-- ========= å½’ä¸€åŒ–ï¼šè¾“å‡ºä¸¤æ¡é€šé“ =========
local function normalizeDual(s)
    if not s or s == "" then
        return "", ""
    end

    s = removeInvisibleAndControls(s)
    s = stripCombiningMarks(s)
    s = toLowerASCII(s)
    s = mapFullwidthAndLeet(s)

    -- è¿‡æ»¤ï¼šFULL é€šé“ä¿ç•™ï¼ˆä¸­æ–‡ + è‹±æ•°ï¼‰ï¼›ALNUM åªä¿ç•™è‹±æ•°
    local fullBuf, alnumBuf = {}, {}
    local i = 1
    while i <= #s do
        local b = s:byte(i)
        if b < 128 then
            -- ASCII
            local ch = s:sub(i,i)
            local isDigit = (b >= 48 and b <= 57)
            local isAlpha = (b >= 97 and b <= 122) or (b >= 65 and b <= 90)

            if isDigit or isAlpha then
                fullBuf[#fullBuf+1] = ch
                alnumBuf[#alnumBuf+1] = ch
            else
                -- å…¶ä½™ ASCII å½“ä½œåˆ†éš”ç¬¦ç›´æ¥ä¸¢æ‰ï¼ˆå¯¹æ’ç¬¦å·æ–­è¯éå¸¸ç‹ ï¼‰
            end
            i += 1
        else
            -- UTF-8 å¤šå­—èŠ‚ï¼šä¿ç•™åˆ° FULLï¼ˆä¸­æ–‡ã€æ—¥æ–‡ç­‰ï¼‰ï¼›ALNUM ä¸è¦
            local cp = utf8.codepoint(s, i)
            local ch = utf8.char(cp)
            fullBuf[#fullBuf+1] = ch
            i += #ch
        end
    end

    local full = collapseRepeatsUtf8(table.concat(fullBuf))
    local alnum = collapseRepeatsUtf8(table.concat(alnumBuf))

    return full, alnum
end

-- ========= Ahoâ€“Corasickï¼ˆbyte-basedï¼›FULL/ALNUM éƒ½å¯ç”¨ï¼‰ =========
local function newNode()
    return {next = {}, fail = 0, out = nil}
end

local function addOut(node, payload)
    if not node.out then node.out = {payload} else node.out[#node.out+1] = payload end
end

local function buildAC(payloads)
    local nodes = { newNode() } -- root=1

    local function insert(word, payload)
        local cur = 1
        for i=1,#word do
            local c = word:byte(i)
            local nxt = nodes[cur].next[c]
            if not nxt then
                nodes[#nodes+1] = newNode()
                nxt = #nodes
                nodes[cur].next[c] = nxt
            end
            cur = nxt
        end
        addOut(nodes[cur], payload)
    end

    for _,p in ipairs(payloads) do
        insert(p.norm, p)
    end

    local q, head = {}, 1
    for _, nxt in pairs(nodes[1].next) do
        nodes[nxt].fail = 1
        q[#q+1] = nxt
    end

    while head <= #q do
        local v = q[head]; head += 1
        for ch, u in pairs(nodes[v].next) do
            local f = nodes[v].fail
            while f ~= 1 and not nodes[f].next[ch] do
                f = nodes[f].fail
            end
            local link = nodes[f].next[ch] or 1
            nodes[u].fail = link
            if nodes[link].out then
                if nodes[u].out then
                    for i=1,#nodes[link].out do nodes[u].out[#nodes[u].out+1] = nodes[link].out[i] end
                else
                    nodes[u].out = table.clone(nodes[link].out)
                end
            end
            q[#q+1] = u
        end
    end

    return nodes
end

local function acScan(nodes, s, hitMap, outArr)
    local state = 1
    for i=1,#s do
        local c = s:byte(i)
        while state ~= 1 and not nodes[state].next[c] do
            state = nodes[state].fail
        end
        state = nodes[state].next[c] or 1
        local out = nodes[state].out
        if out then
            for k=1,#out do
                local p = out[k]
                local key = p.norm .. "|" .. p.cat
                if not hitMap[key] then
                    hitMap[key] = true
                    outArr[#outArr+1] = { word = p.raw, category = p.cat, weight = p.weight }
                end
            end
        end
    end
end

-- ========= çŸ­ç¼©å†™æ»‘çª—æ¨¡ç³Šè¡¥åˆ€ï¼ˆåªå¯¹ ALNUMï¼›å¾ˆçœï¼‰ =========
local function levenshteinLimit(a, b, limit)
    if a == b then return 0 end
    local la, lb = #a, #b
    if math.abs(la - lb) > limit then return limit + 1 end
    local prev = {}
    for j=0,lb do prev[j] = j end
    for i=1,la do
        local cur = {[0]=i}
        local rowMin = cur[0]
        local ai = a:byte(i)
        for j=1,lb do
            local cost = (ai == b:byte(j)) and 0 or 1
            local v = math.min(prev[j] + 1, cur[j-1] + 1, prev[j-1] + cost)
            cur[j] = v
            if v < rowMin then rowMin = v end
        end
        if rowMin > limit then return limit + 1 end
        prev = cur
    end
    return prev[lb]
end

local function fuzzyShortHits(alnum, targets, limit, hitMap, outArr)
    if alnum == "" then return end
    for _,t in ipairs(targets) do
        local lt = #t
        if #alnum >= lt then
            -- æ»‘çª—ï¼šåªæŸ¥ç­‰é•¿çª—å£ï¼Œæçœ
            for i=1, (#alnum - lt + 1) do
                local sub = alnum:sub(i, i+lt-1)
                if levenshteinLimit(sub, t, limit) <= limit then
                    local key = t .. "|fuzzy"
                    if not hitMap[key] then
                        hitMap[key] = true
                        outArr[#outArr+1] = { word = t, category = "fuzzy_short", weight = 4 }
                    end
                    break
                end
            end
        end
    end
end

-- ========= Detector.new / scan =========
function Detector.new(wordsTable)
    -- flatten å¹¶åšåŒé€šé“å½’ä¸€åŒ–è¯æ¡
    local payloads = {}
    local seen = {}

    for cat, list in pairs(wordsTable) do
        if type(list) == "table" then
            local wgt = categoryWeight(cat)
            for i=1,#list do
                local raw = list[i]
                if type(raw) == "string" and raw ~= "" then
                    local full, alnum = normalizeDual(raw)

                    -- FULL payload
                    if full ~= "" then
                        local key = "F|"..full.."|"..tostring(cat)
                        if not seen[key] then
                            seen[key] = true
                            payloads[#payloads+1] = { norm = full, raw = raw, cat = tostring(cat), weight = wgt }
                        end
                    end

                    -- ALNUM payloadï¼ˆåªè¦å®ƒå’Œ full ä¸åŒæˆ–æ›´çŸ­æ—¶ä¹Ÿç•™ç€ï¼Œä¸“æŠ“æ‹¼éŸ³/ç¼©å†™ï¼‰
                    if alnum ~= "" and alnum ~= full then
                        local key2 = "A|"..alnum.."|"..tostring(cat)
                        if not seen[key2] then
                            seen[key2] = true
                            payloads[#payloads+1] = { norm = alnum, raw = raw, cat = tostring(cat), weight = wgt }
                        end
                    end
                end
            end
        end
    end

    local self = setmetatable({
        ac = buildAC(payloads),
        fuzzy = true,           -- é»˜è®¤å¼€ï¼šçŸ­ç¼©å†™è¡¥åˆ€
        fuzzyLimit = 1,
        fuzzyTargets = {"sb","cnm","nmsl","tmd","wdnmd","mlgb","wqnmlgb"},
        cache = {},
        cacheMax = 200,
    }, Detector)

    return self
end

function Detector:scan(text)
    if not text or text == "" then
        return {hit=false, level="clean", score=0, matches={}, norm_full="", norm_alnum=""}
    end

    local cached = self.cache[text]
    if cached then return cached end

    local full, alnum = normalizeDual(text)

    local hitMap = {}
    local matches = {}

    acScan(self.ac, full, hitMap, matches)
    if alnum ~= full then
        acScan(self.ac, alnum, hitMap, matches)
    end

    if self.fuzzy and #matches == 0 then
        fuzzyShortHits(alnum, self.fuzzyTargets, self.fuzzyLimit, hitMap, matches)
    end

    local score = 0
    for i=1,#matches do
        score += (matches[i].weight or 1)
    end

    local level = "clean"
    if score >= 10 then level = "critical"
    elseif score >= 6 then level = "high"
    elseif score >= 3 then level = "medium"
    elseif score >= 1 then level = "low"
    end

    local res = {
        hit = (#matches > 0),
        level = level,
        score = score,
        matches = matches,
        norm_full = full,
        norm_alnum = alnum,
    }

    -- ç®€æ˜“ cacheï¼ˆåˆ·å±é˜²æŠ–ï¼‰
    if self.cacheMax > 0 then
        if (table.getn(self.cache) or 0) > self.cacheMax then
            self.cache = {}
        end
        self.cache[text] = res
    end

    return res
end

return Detector
