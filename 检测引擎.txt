--[[
ğŸ’€ è´´å§ç‹‚æš´ä¸“ç”¨æ£€æµ‹å¼•æ“ v5.1
- ä¸­è‹±æ··åˆæ£€æµ‹ï¼ˆFULL + ALNUM åŒé€šé“ï¼‰
- æ”¯æŒå¸¸è§è°éŸ³/å½¢è¿‘å­—å½’ä¸€ï¼ˆä¸­æ–‡è§„é¿å†™æ³•ï¼‰
- ä¿®å¤ä¸­æ–‡åˆ†è¯åœºæ™¯ï¼ˆç©ºæ ¼/ç¬¦å·æ‹†åˆ†åä»å¯å‘½ä¸­ï¼‰
- è¯­å¢ƒé™è¯¯ä¼¤ï¼šçŸ­è‹±æ–‡è¾¹ç•Œåˆ¤å®š + ä¸­æ–‡ç»„åˆè¯ç™½åå•
- æ—  goto/labelï¼Œå…¼å®¹æ€§æ›´ç¨³
]]

local Detector = {}
Detector.__index = Detector

-- ========= helpers =========
local function clamp(n,a,b)
	if n<a then return a elseif n>b then return b else return n end
end

local function shallowCopy(arr)
	local out = {}
	for i=1,#arr do out[i]=arr[i] end
	return out
end

local function categoryWeight(cat)
	cat = string.lower(tostring(cat or ""))
	if cat:find("advanced") or cat:find("dialect") then return 5 end
	if cat:find("basic") then return 4 end
	if cat:find("english") then return 4 end
	if cat:find("leet") or cat:find("pinyin") or cat:find("abbrev") or cat:find("initial") then return 4 end
	if cat:find("euphem") then return 3 end
	if cat:find("rage") then return 2 end
	if cat:find("memes") then return 1 end
	return 2
end

local function isAsciiAlphaNumByte(b)
	return (b>=48 and b<=57) or (b>=97 and b<=122) or (b>=65 and b<=90)
end

local function toLowerASCII(s)
	return (s:gsub("%u", function(c)
		return string.char(c:byte()+32)
	end))
end

local FULLWIDTH_MAP = {
	["ï¼"]="!",["ï¼‚"]='"',["ï¼ƒ"]="#",["ï¼„"]="$",["ï¼…"]="%",["ï¼†"]="&",["ï¼‡"]="'",
	["ï¼ˆ"]="(",["ï¼‰"]=")",["ï¼Š"]="*",["ï¼‹"]="+",["ï¼Œ"]=",",["ï¼"]="-",["ï¼"]=".",
	["ï¼"]="/",["ï¼š"]=":",["ï¼›"]=";",["ï¼œ"]="<",["ï¼"]="=",["ï¼"]=">",["ï¼Ÿ"]="?",
	["ï¼ "]="@",["ï¼»"]="[",["ï¼¼"]="\\",["ï¼½"]="]",["ï¼¾"]="^",["ï¼¿"]="_",["ï½€"]="`",
	["ï½›"]="{",["ï½œ"]="|",["ï½"]="}",["ï½"]="~",["ã€€"]=" "
}

local LEET_MAP = {
	["@"]= "a", ["$"]= "s", ["!"]= "i", ["|"]= "i",
	["0"]= "o", ["1"]= "i", ["3"]= "e", ["4"]= "a", ["5"]= "s", ["7"]= "t", ["8"]= "b", ["9"]= "g",
}

-- ä¸­æ–‡è°éŸ³/å½¢è¿‘å­—å½’ä¸€ï¼ˆå¸¸è§å¯¹æŠ—å†™æ³•ï¼‰
local FUZZY_CHAR_MAP = {
	["ç¥¢"]="ä½ ",["å¦³"]="ä½ ",["å°“"]="ä½ ",["ä¼±"]="ä½ ",["æ²µ"]="ä½ ",
	["ç‘ª"]="å¦ˆ",["ç›"]="å¦ˆ",["éº»"]="å¦ˆ",["å˜›"]="å¦ˆ",["é¦¬"]="é©¬",
	["è‰¸"]="è‰",["è‰¹"]="è‰",["æ„º"]="è‰",["é¨²"]="è‰",
	["å„"]="å‚»",["ç…"]="å‚»",["æ½µ"]="å‚»",
	["æ»¾"]="æ»š",["è¢"]="æ»š",
	["æ›°"]="æ—¥",["ã„–"]="æ—¥",
	["è…¦"]="è„‘",["æ¼"]="è„‘",
	["å¼"]="å±Œ",["åŠ"]="å±Œ",["é‡£"]="å±Œ",
}

-- ç»„åˆè¯ç™½åå•ï¼ˆä¸»è¦ç”¨äºå•å­—å‘½ä¸­é™è¯¯ä¼¤ï¼‰
local SAFE_PHRASES = {
	"æ˜ŸæœŸæ—¥","æ—¥æœŸ","æ—¥æœ¬","æ—¥å¿—","æ—¥å¸¸","æ—¥å†","æ—¥å‡º","æ—¥è½",
	"è‰è“","è‰åŸ","è‰åœ°","è‰ç¨¿","è‰æ¡ˆ","èµ·è‰","èŠ±è‰",
	"å¦ˆå¦ˆ","å¦ˆå’ª","å§¨å¦ˆ","å§‘å¦ˆ","å¤§å¦ˆ",
	"çˆ·çˆ·","å§¥çˆ·","å¤§çˆ·","å°‘çˆ·",
	"è€çˆ¹","å¹²çˆ¹","çˆ¹å¦ˆ",
	"ä¾é ","å¯é ","é è¿‘","é å²¸"
}

local function safeUtf8(s)
	if type(s)~="string" then return "" end
	if s=="" then return "" end
	local ok, len = pcall(function() return utf8.len(s) end)
	if ok and len ~= nil then return s end
	return (s:gsub("[\128-\255]", ""))
end

local function applyFuzzyZhMap(s)
	s = safeUtf8(s)
	local out = {}
	for _,cp in utf8.codes(s) do
		local ch = utf8.char(cp)
		out[#out+1] = FUZZY_CHAR_MAP[ch] or ch
	end
	return table.concat(out)
end

local function normalizeDual(s)
	s = safeUtf8(s)
	s = s:gsub("[%z\1-\31\127-\159\u{200B}-\u{200F}\u{2060}\u{FEFF}]", "")
	s = s:gsub("[\u{0300}-\u{036F}\u{1AB0}-\u{1AFF}\u{1DC0}-\u{1DFF}\u{20D0}-\u{20FF}\u{FE20}-\u{FE2F}]", "")
	s = toLowerASCII(s)
	s = applyFuzzyZhMap(s)

	s = s:gsub("[%z\1-\127\u{3000}-\u{FFEF}]", function(ch)
		return FULLWIDTH_MAP[ch] or ch
	end)

	s = s:gsub(".", function(ch)
		return LEET_MAP[ch] or ch
	end)

	local fullBuf, alnumBuf = {}, {}
	local i = 1
	while i <= #s do
		local b = s:byte(i)
		if b and b < 128 then
			local ch = s:sub(i,i)
			if isAsciiAlphaNumByte(b) then
				fullBuf[#fullBuf+1] = ch
				alnumBuf[#alnumBuf+1] = ch
			end
			i += 1
		else
			local ok, cp = pcall(function() return utf8.codepoint(s, i) end)
			if ok and cp then
				local ch = utf8.char(cp)
				fullBuf[#fullBuf+1] = ch
				i += #ch
			else
				i += 1
			end
		end
	end

	local full = table.concat(fullBuf)
	local alnum = table.concat(alnumBuf)

	full = full:gsub("(%a)%1%1+", "%1%1")
	alnum = alnum:gsub("(%a)%1%1+", "%1%1")

	return full, alnum
end

-- ========= AC =========
local function newNode()
	return {next={}, fail=1, out=nil}
end

local function pushOut(node, p)
	if not node.out then node.out={p} else node.out[#node.out+1]=p end
end

local function buildAC(payloads)
	local nodes = {newNode()}
	for _,p in ipairs(payloads) do
		local cur = 1
		for i=1,#p.norm do
			local c = p.norm:byte(i)
			local nxt = nodes[cur].next[c]
			if not nxt then
				nodes[#nodes+1] = newNode()
				nxt = #nodes
				nodes[cur].next[c] = nxt
			end
			cur = nxt
		end
		pushOut(nodes[cur], p)
	end

	local q, head = {}, 1
	for _,nxt in pairs(nodes[1].next) do
		nodes[nxt].fail=1
		q[#q+1]=nxt
	end

	while head<=#q do
		local v=q[head]; head+=1
		for ch,u in pairs(nodes[v].next) do
			local f=nodes[v].fail
			while f~=1 and not nodes[f].next[ch] do f=nodes[f].fail end
			local link=nodes[f].next[ch] or 1
			nodes[u].fail=link
			if nodes[link].out then
				if nodes[u].out then
					for i=1,#nodes[link].out do nodes[u].out[#nodes[u].out+1]=nodes[link].out[i] end
				else
					nodes[u].out=shallowCopy(nodes[link].out)
				end
			end
			q[#q+1]=u
		end
	end
	return nodes
end

local function acScan(nodes, s, onHit)
	local st = 1
	for i=1,#s do
		local c = s:byte(i)
		while st~=1 and not nodes[st].next[c] do st = nodes[st].fail end
		st = nodes[st].next[c] or 1
		local out = nodes[st].out
		if out then
			for k=1,#out do onHit(out[k], i) end
		end
	end
end

local function boundaryOK(s, st, ed)
	local lb = (st>1) and s:byte(st-1) or nil
	local rb = (ed<#s) and s:byte(ed+1) or nil
	local leftOK = (not lb) or (not isAsciiAlphaNumByte(lb))
	local rightOK = (not rb) or (not isAsciiAlphaNumByte(rb))
	return leftOK and rightOK
end

local function buildSafeSpans(s)
	local spans={}
	for i=1,#SAFE_PHRASES do
		local ph=SAFE_PHRASES[i]
		local st=1
		while true do
			local a,b = s:find(ph, st, true)
			if not a then break end
			spans[#spans+1] = {a,b}
			st = a + 1
		end
	end
	return spans
end

local function inSafeSpan(spans, st, ed)
	for i=1,#spans do
		local a,b = spans[i][1], spans[i][2]
		if st>=a and ed<=b then return true end
	end
	return false
end

local SHORT_EN_STRICT = { ass=true, damn=true, crap=true }

-- ========= API =========
function Detector.new(wordsTable, opts)
	wordsTable = wordsTable or {}
	opts = opts or {}

	local payloadFull, payloadAlnum = {}, {}
	local uniqFull, uniqAlnum = {}, {}

	for cat, list in pairs(wordsTable) do
		if type(list)=="table" then
			for i=1,#list do
				local raw = tostring(list[i] or "")
				if raw ~= "" then
					local full, alnum = normalizeDual(raw)
					local w = categoryWeight(cat)
					if #full>=1 and not uniqFull[full] then
						uniqFull[full]=true
						payloadFull[#payloadFull+1]={norm=full, raw=raw, cat=cat, weight=w, channel="full"}
					end
					if #alnum>=2 and not uniqAlnum[alnum] then
						uniqAlnum[alnum]=true
						payloadAlnum[#payloadAlnum+1]={norm=alnum, raw=raw, cat=cat, weight=w, channel="alnum"}
					end
				end
			end
		end
	end

	local self=setmetatable({}, Detector)
	self.acFull = buildAC(payloadFull)
	self.acAlnum = buildAC(payloadAlnum)
	self.opts = {
		maxHits = tonumber(opts.maxHits) or 28,
		scoreCap = tonumber(opts.scoreCap) or 100,
	}
	return self
end

function Detector:scan(text)
	local full, alnum = normalizeDual(tostring(text or ""))
	local safeSpansFull = buildSafeSpans(full)

	local hitMap, hits, categories = {}, {}, {}
	local score = 0

	local function consume(payload, ed, channelText)
		local st = ed - #payload.norm + 1
		if st < 1 then return end

		if payload.channel=="alnum" then
			if SHORT_EN_STRICT[payload.norm] and not boundaryOK(channelText, st, ed) then return end
		elseif payload.channel=="full" then
			if #payload.norm<=1 and inSafeSpan(safeSpansFull, st, ed) then return end
		end

		local key = payload.channel.."|"..payload.norm.."|"..st
		if hitMap[key] then return end
		hitMap[key] = true

		hits[#hits+1] = {
			word = payload.raw,
			norm = payload.norm,
			cat = payload.cat,
			channel = payload.channel,
			startPos = st,
			endPos = ed,
		}
		categories[payload.cat] = true
		score += payload.weight
	end

	acScan(self.acFull, full, function(p, ed) consume(p, ed, full) end)
	acScan(self.acAlnum, alnum, function(p, ed) consume(p, ed, alnum) end)

	if #hits > self.opts.maxHits then
		while #hits > self.opts.maxHits do table.remove(hits) end
	end

	score = clamp(score, 0, self.opts.scoreCap)
	return {
		hit = #hits > 0,
		score = score,
		hits = hits,
		categories = categories,
		norm = {full=full, alnum=alnum},
	}
end

return Detector
